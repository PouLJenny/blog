---
layout: post
title:  "23种设计模式-单例模式"
date:   2024-03-07 14:36:00 +0800
categories: 设计模式
tags: 设计模式
permalink: /patterns/singleton
published: true
publish_file: 2024-03-07-patterns-singleton.md
toc: true
---
# 设计模式-单例模式

## Intent/目的

确保类只有一个实例，并提供全局的访问点。

## Motivation/动机

对于某些类来说，拥有确切的一个实例是很重要的。尽管在系统中可以有许多打印机，但打印池应该只有一个。应该只有一个文件系统和一个窗口管理器。数字滤波器将有一个模数转换器。会计系统将专门为一家公司提供服务。

我们如何确保一个类只有一个实例，并且该实例易于访问？全局变量使对象可访问，但它不能阻止您实例化多个对象。

一个更好的解决方案是使类本身负责跟踪其唯一实例。类可以确保不会创建其他实例（通过拦截创建新对象的请求），并且可以提供访问实例的方式。这就是单例模式。

## Applicability/应用场景

- 一个类必须存在且仅存在一个实例，并且客户端必须能够从一个已知的访问点访问该实例。
- 唯一实例应该可以通过子类化进行扩展，并且客户端应该能够在不修改其代码的情况下使用扩展实例。

## Structure/结构

![](/assets/notes/patterns/singleton_01.png)

## Participants/角色

- Singleton
  - 定义了一个 Instance 操作，让客户端访问其唯一实例。Instance 是一个类的方法。

## Consequences/总结

单例模式有几个优点：

1. 控制对唯一实例的访问。由于单例类封装了其唯一实例，它可以严格控制客户端如何以及何时访问它。
2. 减少命名空间。单例模式是对全局变量的改进。它避免了用存储唯一实例的全局变量来污染命名空间。
3. 允许操作和表示的细化。单例类可以被子类化，很容易用扩展类的实例配置应用程序。您可以在运行时配置应用程序使用所需的类的实例。
4. 允许可变数量的实例。该模式使得很容易改变主意并允许单例类有多个实例。此外，您可以使用相同的方法来控制应用程序使用的实例数量。只需要改变授予对单例实例访问的操作即可。
5. 比类操作更灵活。包装单例功能的另一种方式是使用类操作（即，在C++中的静态成员函数或Smalltalk中的类方法）。但是这两种语言技术都很难更改设计以允许类有多个实例。此外，在C++中的静态成员函数从不是虚拟的，因此子类无法多态地覆盖它们。

## Related Patterns/相关的模式

很多设计模式都会通过单例模式来实现。比如抽象工厂模式、构造器模式、原型模式。