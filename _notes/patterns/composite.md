# Composite模式 组合模式

## Intent/目的

将对象组合成树形结构，以表示部分-整体的层次关系。组合模式让客户端能够统一地处理单个对象和对象组合。

## Motivation/动机

图形应用程序，如绘图编辑器和原理图捕获系统，允许用户通过简单组件构建复杂的图表。用户可以将组件分组形成更大的组件，这些更大的组件又可以被分组形成更大的组件.一个简单的实现可以定义图形原语的类，例如文本和线条，以及其他作为这些原语容器的类。

但是，这种方法存在一个问题：使用这些类的代码必须区分原始对象和容器对象，即使大多数情况下用户将它们视为相同的。必须区分这些对象会使应用程序变得更加复杂。组合模式描述了如何使用递归组合，使客户端不必进行此区分。

![](/assets/notes/patterns/composite_01.png)

组合模式的关键是一个抽象类，代表了原语和它们的容器。对于图形系统来说，这个类就是 `Graphic`。`Graphic` 声明了诸如 `Draw` 等特定于图形对象的操作。它还声明了所有组合对象共享的操作，例如用于访问和管理其子对象的操作。

子类 `Line`、`Rectangle` 和 `Text`（参见前面的类图）定义了原始的图形对象。这些类实现了 `Draw `方法来绘制线条、矩形和文本。由于原始图形没有子图形，因此这些子类都不实现与子对象相关的操作。

`Picture` 类定义了一组 `Graphic` 对象的聚合体。`Picture` 实现了 `Draw` 方法来调用其子对象的` Draw `方法，并相应地实现了与子对象相关的操作。由于 `Picture` 接口符合 `Graphic` 接口，因此 `Picture` 对象可以递归地组合其他 `Picture` 对象。

下表显示了典型的递归组合的` Graphic` 对象的复合对象结构：

![](/assets/notes/patterns/composite_02.png)

## Applicability/应用场景

- 你想要表示对象的部分-整体层次结构。
- 你希望客户端能够忽略对象组合和单个对象之间的差异。客户端将统一对待组合结构中的所有对象。

## Structure/结构

![](/assets/notes/patterns/composite_03.png)

典型的组合对象结构：

![](/assets/notes/patterns/composite_04.png)

## Participants/角色



## Consequences/总结

## Related Patterns/相关的模式