# Flyweight模式 享元模式

## Intent/目的

使用共享来有效地支持大量的细粒度对象。

## Motivation/动机

一些应用程序可以通过在其设计中贯穿使用对象来受益，但是一个简单的实现会代价昂贵到令人望而却步。

例如，大多数文档编辑器实现都在某种程度上模块化了文本格式化和编辑功能。面向对象的文档编辑器通常使用对象来代表嵌入的元素，如表格和图形。然而，他们通常不会为文档中的每一个字符使用一个对象，尽管这样做可以在应用程序的最细层次上促进灵活性。这样，字符和嵌入的元素就可以在它们如何被绘制和格式化方面被统一处理。应用程序可以扩展以支持新的字符集，而不影响其他功能。应用程序的对象结构可以模仿文档的物理结构。以下图表展示了一个文档编辑器如何使用对象来代表字符。

![](/assets/notes/patterns/flyweight_01.png)

这种设计的缺点是它的成本。即使是中等大小的文档也可能需要成千上万的字符对象，这将消耗大量内存并可能导致无法接受的运行时开销。享元模式描述了如何共享对象，以允许在不引起过高成本的情况下，以细粒度使用它们。

享元是一种可以同时在多个上下文中使用的共享对象。在每个上下文中，享元表现得就像一个独立的对象——它与未共享的对象实例无法区分。享元不能对它们操作的上下文做出假设。这里的关键概念是内在状态和外在状态之间的区别。内在状态存储在享元中；它包括与享元的上下文无关的信息，因此可以共享。外在状态依赖于并随享元的上下文变化，因此不能共享。客户端对象负责在需要时将外在状态传递给享元。

逻辑上，文档中给定字符的每次出现都有一个对象：

![](/assets/notes/patterns/flyweight_02.png)

然而，在物理上，每个字符只有一个共享的享元对象，并且它在文档结构的不同上下文中出现。特定字符对象的每次出现都引用共享的享元对象池中的同一个实例：

![](/assets/notes/patterns/flyweight_03.png)

接下来展示的是这些对象的类结构。`Glyph` 是图形对象的抽象类，其中一些可能是享元。依赖于外在状态的操作将外在状态作为参数传递给它们。例如，`Draw` 和 `Intersects` 必须知道 `glyph` 在哪个上下文中，才能执行它们的工作。

![](/assets/notes/patterns/flyweight_04.png)

代表字母 "a" 的享元仅存储相应的字符代码；它不需要存储其位置或字体。客户端提供享元绘制自己所需的依赖于上下文的信息。例如， `Row` glyph 知道其子元素应该在哪里绘制自己以便它们水平排列。因此，它可以在绘制请求中传递给每个子元素其位置。

因为不同字符对象的数量远小于文档中的字符数量，所以总共的对象数量大大少于一个简单实现所使用的数量。在一个所有字符都以相同字体和颜色出现的文档中，无论文档的长度如何，都将分配大约100个字符对象（大致相当于ASCII字符集的大小）。而且，由于大多数文档使用的不同字体-颜色组合不超过10种，因此这个数字在实践中不会显著增长。因此，对于单个字符来说，对象抽象变得切实可行。

## Applicability/应用场景

享元模式的有效性在很大程度上取决于它如何以及在哪里被使用。当以下所有条件都满足时，应用享元模式:
- 应用程序使用了大量的对象。
- 由于对象数量众多，存储成本很高。
- 大多数对象状态可以变为外在的。
- 一旦移除外在状态，许多组对象可以被相对较少的共享对象替代。
- 应用程序不依赖于对象身份。由于享元对象可能会被共享，身份测试对于概念上不同的对象将返回真（true）。

## Structure/结构

![](/assets/notes/patterns/flyweight_05.png)


![](/assets/notes/patterns/flyweight_06.png)


## Participants/角色




## Consequences/总结



## Related Patterns/相关的模式

