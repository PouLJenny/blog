# 排序

## 选择排序

首先找到数组中最小的元素，其次，将它和数组的第一个元素交换位置（如果第一个元素最小那么自己和自己交换位置）。
再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素位置交换。
如此往复，直到将整个数组排序。这种方式叫做选择排序，因为它在不断的选择剩余元素之中的最小者。


时间复杂度
比较次数 = (N-1) + (N-2) ... + 1 = (N-1)N/2 = N$^2$/2 - N/2 $\thickapprox$ N$^2$ / 2
交换次数 = N - 1 $\thickapprox$ N

空间复杂度
原地排序，1

特点：
1. 运行时间稳定，不管输入的是排好序的还是乱序的都不影响算法的效率
2. 数据移动是最少的，元素交换的次数跟数组的长度成线性关系，也就是N次。其他的排序算法都不会达到这种效果

## 插入排序
通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，
为了给要插入的元素腾空间。需要将所有其余的元素在插入之前都要向后移动一位。这种算法叫插入排序。

时间复杂度
最好情况（正序数组）
比较次数 = N - 1 $\thickapprox$ N
交换次数 = 0

最坏情况（逆序数组）
比较次数 = 1 + 2 + 3 + ... + N - 1 = (N-1)N/2 $\thickapprox$  N$^2$ / 2
交换次数 = 2 + 3 + 4 + ... + N = (N+2)(N-1)/2 $\thickapprox$  N$^2$ / 2

平均情况
比较次数 $\thickapprox$  N$^2$ / 4
交换次数 $\thickapprox$  N$^2$ / 4

空间复杂度
原地排序，1

特点：
1. 排序时间跟输入数组的关系比较大，时间复杂度非常不稳定
2. 插入排序对**部分有序数组**非常有效，当**倒置**的元素很少时，插入排序效率特别高，几乎所有排序算法中最高的。
3. 非常适合小数组

定理：
插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小减一。


## 希尔排序
基于插入排序的快速排序算法。
希尔排序的思想是使任意间隔为h的元素都是有序的。这样的数组称为h有序数组。换句话说，一个h有序数组，就是h个互相独立的有序数组编织在一起形成的数组。
在进行排序时，如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便。

时间复杂度：
学术界没有啥好的办法去衡量，但是实际效果是比选择排序和插入排序快的

特点：
1. 适合大的乱序数组
2. 比插入排序和选择排序要快的多
3. 代码实现相对比较简单，性能也不是很差，其他的高效算法也就比希尔排序快2倍左右，如果说你要解决一个排序问题，但是还没有系统函数可以调用的话，可以优先考虑实现希尔排序。

## 归并排序（自顶向下）
基于归并操作，即将两个有序数组合并成更大的有序数组来实现的。
要将数组排序，可以先（递归地）将它分成两半分别排序，然后将结果合并起来。

时间复杂度：
比较次数 = 1/2N$lg$N ~ N$lg$N

数组的访问次数 = 6N$lg$N

特点：
1. 效率提升很明显，可以对超大规模的数组进行排序
2. 算法需要的额外空间是N的线性关系
3. 对于含有以任意概率分布的重复元素的输入，归并排序无法保证最佳性能。

## 归并排序 + 插入排序
小的数组使用插入排序,可以使性能提高10% ～ 15%

## 归并排序（自低向上）
先归并一些微型数组，然后在归并大的数组

时间复杂度：
比较次数 = 1/2N$lg$N ~ N$lg$N

数组的访问次数 = 6N$lg$N

## 快速排序
快速排序是一种分治的思想。快速排序和归并排序是互补的。归并排序是将数组分成两个字数组来分别排序，然后将两个有序的数组合并成一个大的有序数组。而快速排序是主要思想是两个字数组都有序的时候，整个数组自然也就有序了。

归并排序中，数组每次都被切分成2半。快速排序切分的位置，取决于数组的内容。

找到切分点的方式。一般策略是随意的取数组的最左端元素作为*切分元素*，然后从数组的左端向右扫描，直到找到**一个大于等于它**的元素，再从数组的右端开始扫描，直到找到**一个小于等于它**的元素。这两个元素显然是没有排好序的，因此**交换**它们的位置。如此继续，直到我们选定的切分元素的左边都**不大于**它，右边都**不小于**它。

时间复杂度：
平均比较次数 $\thickapprox$  2N$ln$N  $\thickapprox$ 1.39N$lg$N
最多比较次数 N$^2$/2 但随机打乱的数组能预防这种情况

特点：
1. 它是一个随机话的算法，在排序之前要吧数组打乱
2. 在切分不平衡的时候这个程序的效率非常低


## 快速排序 + 插入排序
小的数组(5~15)使用插入排序来提高性能


## 三分切的快速排序
由于重复元素导致的经典快速排序算法也会进行比较交换，为了降低这一部分内容，有人提出了将数组分成三部分，分别对应的是**小于、等于、大于**切分元素的数组元素。

下面是java代码示例，可以看到还是很简单的。10行代码就可以搞定一个快速排序。

```java
public void quitSort(int[] nums) {
    quitSort(nums,0,nums.length - 1);
}

public void quitSort(int[] nums,int lo,int hi) {
    if (lo >= hi) return;
    int lt = lo,gt = hi,i = lo + 1;
    int v = nums[lo];// 选定一个切分元素
    while(i <= gt) {
        if (nums[i] < v) swap(nums, lt++, i++);
        else if (nums[i] > v) swap(nums, i, gt--); // 交换数组中的两个元素，在这里就不贴出来了，自行实现，非常简单的。
        else i++;
    }
    quitSort(nums,lo,lt - 1);
    quitSort(nums,gt + 1,hi);
} 
```

特点：
1. 经过精心调优的快速排序在绝大多数场景中都优于其他基于比较的排序算法。

## 优先队列
许多应用程序都需要处理有序的元素，但不一定要求他们全部有序，或是不一定要一次就将他们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。

可以删除最大元素，插入新元素的数据结构，叫做优先队列

主要解决的问题：
输入N（可以无穷大）个字符串，从中找出最大的M个值。这个不就是**topN问题**吗！！

优先队列的实现方式，及其最坏情况下的时间复杂度:
|数据结构|插入元素|删除最大元素|
|--|--|--|
|有序数组|N|1|
|无序数组|1|N|
|堆|$log_2N$|$log_2N$|


**二叉堆** 每个元素都要保证大于等于另两个特定位置的元素。相应地，这些位置的元素又要大于等于数组中的另外两个元素，以此类推。


当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为**堆有序**。

**二叉堆**  严格定义： 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）

在一个堆中，位置$k$的结点的父节点的位置为$\lfloor k/2 \rfloor$,两个子结点的位置分别是$2k$和$2k+1$

对于一个含有N个元素的基于堆实现的优先队列，插入元素操作不超过$lgN+1$次比较,
删除最大元素不超过$2lgN$次比较

二叉堆分成两种形式，
1. 最大堆 父节点大于等于子结点
2. 最小堆 父节点小于等于子结点

## 堆排序
分为两个阶段：
1. 堆的构造阶段 
    使用下沉操作构建堆的时候，只需少于2N次比较以及少于N次交换
2. 下沉排序阶段
    每次下沉操作最多需要2lgN次比较


时间复杂度
最坏情况比较次数= 2NlgN + 2N
最坏交换次数 = NlgN + N

空间复杂度
1

特点：
1. 无需额外空间
2. 代码量小
4. 无法高效利用缓存，因为不是按照数组的index顺序扫描的
5. 能解决topM和Multiway问题，而且总数据量可以很大

## 低位优先字符串排序

此排序方式适合等长、小规模的字符串集合

## 高位优先字符串排序

## 三向字符串快速排序

## 总结


