# 接口幂等

## What
- 一次和多次请求某一个资源对于资源本身应该具有同样的结果
- **任意多次执行对资源本身所产生的影响均与一次执行的影响相同**

幂等性定义的几个重点:
- 幂等不仅仅只是一次或者多次请求对资源没有副作用
  - 比如,查询数据库操作,没有增删改,无论多少次操作对数据库都没有任何影响
- 幂等还包括第一次请求的时候对资源产生了副作用,但是以后的多次请求都不会再对资源产生副作用
- 幂等关注的是以后多次请求是否对资源产生副作用,并不关注结果
- 网络超时等问题,不是幂等的讨论范围
- 幂等性是系统服务对外一种承诺,而不是实现
- 承诺只要调用接口成功,外部多次调用对系统的影响是一致的

## Why
- 网络问题，导致请求超时，没有收到相应结果
- 前端的操作抖动造成的重复提交的情况
- 交易系统中,支付系统，不能生成重复订单，不能重复扣款
- 声明幂等的服务认为,外部调用者会存在多次调用的情况,为了防止外部多次调用对系统的数据状态发生多次改变,需要将服务设计为幂等


## 幂等和防重的细微的差别

- 防重， 重复提交是在第一次请求已经成功的情况下 ,人为地进行多次操作, 导致不满足幂等要求的服务多次改变状态
- 幂等更多使用的情况是第一次请求因为某些情况,比如超时,而导致不知道结果或者请求失败的异常情况下,发起多次请求

## How/常见的方案

1. **业务表内唯一索引**
   - 相同的业务单号,认为是同一业务
   - 使用唯一的业务单号确保: 后面多次相同业务单号的处理逻辑和执行效果是一致的
2. 业务表内状态机
  `update order set status = '待发货' where status = '待付款' and id = 1`
3. 基于版本号的更新
   类似于乐观锁的机制，先查询数据的版本然后带着版本号去更新
  `update user set age = 21 ,version = version + 1 where id = 1 and version = 1`
4. **基于mysql的去重表**
   参数（全部或者部分有标志性的）拼接成唯一字符串,使用mysql表的唯一索引作约束
5. 基于redis的去重
   参数拼接成唯一字符串，参数可全部也可选择一些有标识性的
   `redis: set key value`
   这个方案有个比较大的问题就是数据量过大的情况下redis key太多，如果设置超时时间（比如7天）的话，重复请求7天以上的数据也会有问题。 倒是可以采用redis的bitmap数据结构来控制。但是这样的话你的key就不能用hash值，因为不管是什么hash算法都有可能会出现冲突的情况。






