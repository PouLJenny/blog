# 分布式事务

## XA(eXtended Architecture)规范和理论介绍


### What

[wiki介绍](https://en.wikipedia.org/wiki/X/Open_XA#cite_note-Kleppmann2017-1 '')
[官方说明书](https://pubs.opengroup.org/onlinepubs/009680699/toc.pdf '')

国外的X/OPEN 组织1991年就已经提出了解决方案了，这可真的是让人汗颜啊！！

上一讲演示的过程中，如果一个系统操作多个数据库，肯定是有跨多个库的分布式事务的一个问题，在很多年之前全世界，老美早就已经发现这个问题了，很早以前就定义了一整套的解决方案来处理分布式事务的问题

有个叫做X/Open的组织定义了分布式事务的模型，这里面有几个角色，就是**AP**（Application，应用程序），**TM**（Transaction Manager，事务管理器），**RM**（Resource Manager，资源管理器），**CRM**（Communication Resource Manager，通信资源管理器）

这么说有点儿抽象，其实Application说白了就是我们的系统，TM的话就是一个在系统里嵌入的一个专门管理横跨多个数据库的事务的一个组件，RM的话说白了就是数据库（比如MySQL），CRM可以是消息中间件（但是也可以不用这个东西）

然后这里定义了一个很重要的概念，就是全局事务，这个玩意儿说白了就是一个横跨多个数据库的事务，就是一个事务里，涉及了多个数据库的操作，然后要保证多个数据库中，任何一个操作失败了，其他所有库的操作全部回滚，这就是所谓的分布式事务

上面这套东西就是所谓的X/Open组织搞的一个分布式事务的模型，那么XA是啥呢？说白了，就是定义好的那个TM与RM之间的接口规范，就是管理分布式事务的那个组件跟各个数据库之间通信的一个接口，说白了就是这个意思

完了比如管理分布式事务的组件，TM就会根据XA定义的接口规范，刷刷刷跟各个数据库通信和交互，告诉大家说，各位数据库同学一起来回滚一下，或者是一起来提交个事务把，大概这个意思

这个XA仅仅是个规范，具体的实现是数据库厂商来提供的，比如说MySQL就会提供XA规范的接口函数和类库实现，等等



## 2PC （Two-Phase Commit）

### What

X/Open组织定义的一套分布式事务的模型，还是比较虚的，还没办法落地，而且XA接口规范也是一个比较务虚的一个东西，光靠我说的这些东西还是没法落地的

基本上来说，你搞明白了XA也就明白了2PC了，2PC说白了就是基于XA规范搞的一套分布式事务的理论，也可以叫做一套规范，或者是协议，都ok。Two-Phase-Commitment-Protocol，两阶段提交协议


### How
2PC，其实就是基于XA规范，来让分布式事务可以落地，定义了很多实现分布式事务过程中的一些细节

#### 准备阶段

画个图来玩玩儿，用咱们的那个流量充值的例子来举个例子好了，简单来说，就是TM先发送个prepare消息给各个数据库，让各个库先把分布式事务里要执行的各种操作，先准备执行，其实此时各个库会差不多先执行好，就是不提交罢了

如果你硬是要理解一下的话，也可以认为是prepare消息一发，各个库先在本地开个事务，然后执行好SQL，万事俱备只欠东风了，而且注意这里各个数据库会准备好随时可以提交或者是回滚，有对应的日志记录的

然后各个数据库都返回一个响应消息给事务管理器，如果成功了就发送一个成功的消息，如果失败了就发送一个失败的消息


#### 提交阶段

第一种情况，要是TM哥儿们发现某个数据库告诉他说，不好意思啊，我这儿失败了，那就尴尬了。或者是TM等了半天，某个数据库楞是死活不返回消息，跟失踪了一样，不知道在干嘛，也就麻烦了

这个时候TM直接判定这个分布式事务失败，毕竟某个数据库那里报了个错么，对不对，然后TM通知所有的数据库，全部回滚回滚回滚，赶紧的，做了啥操作都回滚，其实这里你可以认为是通知每个数据库，把自己本地的那个事务回滚不就得了，然后各个库都回滚好了以后就通知TM，TM就认为整个分布式事务都回滚了

但是呢，要是TM接收到所有的数据库返回的消息都是成功，那就happy了，直接发送个消息通知各个数据库说提交，兄弟们，然后各个数据库都在自己本地提交事务呗，就这么回事儿，提交好了通知下TM，TM要是发现所有数据库的事务都提交成功了，就认为整个分布式事务成功了


#### 缺陷
1. 同步阻塞：在阶段一里执行prepare操作会占用资源，一直到整个分布式事务完成，才会释放资源，这个过程中，如果有其他人要访问这个资源，就会被阻塞住

2. 单点故障：TM是个单点，一旦挂掉就完蛋了

3. 事务状态丢失：即使把TM做成一个双机热备的，一个TM挂了自动选举其他的TM出来，但是如果TM挂掉的同时，接收到commit消息的某个库也挂了，此时即使重新选举了其他的TM，压根儿不知道这个分布式事务当前的状态，因为不知道哪个库接收过commit消息，那个接收过commit消息的库也挂了，兄弟

4. 脑裂问题：在阶段二中，如果发生了脑裂问题，那么就会导致某些数据库没有接收到commit消息，那就完蛋了，有些库收到了commit消息，结果有些库没有收到，这咋整呢，那肯定完蛋了

## 3PC

### What

3PC，说白了，就是three-phase-commitment，三阶段提交协议，这个是针对2PC做的一个改进，主要就是为了解决2PC协议的一些问题

3PC的话改成了下面的过程：

（1）**CanCommit**阶段：这个就是TM发送一个CanCommit消息给各个数据库，然后各个库返回个结果，注意一下，这里的话呢，是不会执行实际的SQL语句的，其实说白了，就是各个库看看自己网络环境啊，各方面是否ready

（2）**PreCommit**阶段：如果各个库对CanCommit消息返回的都是成功，那么就进入PreCommit阶段，TM发送PreCommit消息给各个库，这个时候就相当于2PC里的阶段一，其实就会执行各个SQL语句，只是不提交罢了；如果有个库对CanCommit消息返回了失败，那么就尴尬了，TM发送abort消息给各个库，大家别玩儿了，结束这个分布式事务

（3）**DoCommit**阶段：如果各个库对PreCommit阶段都返回了成功，那么发送DoCommit消息给各个库，就说提交事务吧，兄弟们，各个库如果都返回提交成功给TM，那么分布式事务成功；如果有个库对PreCommit返回的是失败，或者超时一直没返回，那么TM认为分布式事务失败，直接发abort消息给各个库，说兄弟们回滚吧，各个库回滚成功之后通知TM，分布式事务回滚

说白了大概就是这样子，但是这里的话，跟2PC相比，主要做了下面两个改进点：

（1）引入了CanCommit阶段

（2）在DoCommit阶段，各个库自己也有超时机制，也就是说，如果一个库收到了PreCommit自己还返回成功了，等了一会儿，如果超时时间到了，还没收到TM发送的DoCommit消息或者是abort消息，直接判定为TM可能出故障了，人家库自己颠儿颠儿的就执行DoCommit操作，提交事务了。

因为这里就是说，如果这个库接收到了PreCommit消息，说明第一阶段各个库对CanCommit都返回成功了啊，这样TM才会发送PreCommit来，那么就默认为基本上各个库的PreCommit都会成功，所以大家没接收到DoCommit，直接自己执行提交操作了

所以这个超时的机制是基于CanCommit的引入来实现的，有了一个CanCommit多了一个阶段，大家才能自己执行超时commit机制，这不就解决了TM挂掉的单点问题么，大家想想是不是这样子

另外资源阻塞问题也能减轻一下，因为一个库如果一直接收不到DoCommit消息，不会一直锁着资源，人家自己会提交释放资源的，所有能减轻资源阻塞问题，比2PC稍微好一些吧而已

3PC的缺陷：

但是其实这种的话，也不是完全就一定好的，因为还是可能有问题啊，如果人家TM在DoCommit阶段发送了abort消息给各个库，结果因为脑裂问题，某个库没接收到abort消息，自己还颠儿颠儿的执行了commit操作，不是也不对么

所以啊，其实2PC也好，3PC也好，都没法完全保证分布式事务的ok的，要明白这一点，总有一些特殊情况下会出问题的


## TCC 方案
try-confirm-cancel

## 适合长事务的sagas

## 本地消息表的方案

## 可靠消息最终一致性

### What 是什么？

包含4个组件/概念
- 上游服务
    调用方
- 可靠消息服务
    协调上下游
- MQ
    一般是RocketMQ或者是RabbitMQ
- 下游服务 
    被调用方


初步操作流程：
1. 上游服务发送待确认消息给可靠消息服务
2. 可靠消息服务将这个待确认的消息保存到自己本地数据库，但是不发MQ，消息状态为“**待确认**”
3. 上游服务操作本地数据库
4. 上游服务根据自己操作本地数据库的结果，通知可靠消息服务，可以确认发送消息，或者是**删除**消息
5. 可靠消息服务将这个消息的状态修改为“**已发送**”，并且将消息发送到MQ消息中间件中去
    这个环节，必须包裹在一个事务里面,先改数据库，再发送MQ
    ```java
    @Transactional
        public void confirmMessage(Long messageId) {
        messageDAO.updateStatus(messageId, MessageStatus.SENT);
        rabbitmqProducer.send(message);
    }
    ```
    MQ的事务消息最好别轻易用，因为那个性能实在是太低了，**吞吐量太差**
6. 下游服务从MQ中监听到一条消息
7. 根据消息在自己本地操作数据库
8. 下游服务对本地数据库操作完成之后，对MQ进行ACK操作，确认这个消息处理成功
9. 下游服务对MQ进行ACK之后，再通知可靠消息服务，我这边处理完层，可靠消息服务把消息的状态改成"**已完成**"

![](./pic/message-consistence.svg)

各个环节失败分析：

1. 步骤1失败 上游服务会直接报错，流程结束
2. 步骤2失败 步骤1和2是一次同步操作，如果步骤2失败，可靠消息服务会直接返回错误信息给步骤1，流程结束， 
    这个地方上游服务可以适当的重试几次
3. 步骤3失败 上游服务本地事务回滚，会通知可靠消息服务删除消息， 流程结束
4. **步骤4失败** 可靠消息服务没有收到服务，上游服务操作完成事务提交了。最终导致数据不一致
5. **步骤5失败** 消息一直为待确认状态，最终导致数据不一致
6. 步骤6、7、8失败 因为有ACK机制，所以没有ACK的话，MQ会一直重试投递
7. **步骤9失败**  可靠消息中的消息状态一直是“已发送”，

通过分析发现 步骤4、5、9失败的话，会导致整个方案出现问题。
下面根据这些问题来提出相应的解决方案

首先解决4、5步骤失败的问题,
可靠消息服务可以加一个定时任务，扫描**待确认且超时**的消息

解决7、8、9失败的方式
可靠消息服务可以加一个定时任务，扫描**已发送且超时**的消息

![](./pic/message-consistence2.svg)


### Where 适用于什么场景呢？

对接第三方的支付系统/流量充值系统，对实时性要求不高的场景。

## 最大努力通知方案

### What

### Where
业务执行完毕，发送短信、邮件的这种消息。
可以接受异步，不用实时。






