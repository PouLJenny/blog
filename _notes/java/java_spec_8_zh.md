# [Java语言规范翻译](https://docs.oracle.com/javase/specs/index.html )


## 17 Threads and Locks

### 17.4 Memory Model
内存模型（Memory Model）描述了一个程序和该程序的执行轨迹，给出了该执行轨迹是否是该程序的合法执行。Java编程语言的内存模型通过检查执行轨迹中的每个读取，并检查该读取所观察到的写入是否根据某些规则有效来工作。

内存模型描述了程序的可能行为。一个实现可以生成任何它喜欢的代码，只要程序的所有结果执行都能够被内存模型所预测。

这为实现者提供了很大的自由度，可以进行各种代码转换，包括重新排序操作和删除不必要的同步。

Example 17.4-1. Incorrectly Synchronized Programs May Exhibit Surprising Behavior

Java编程语言的语义允许编译器和微处理器执行优化，这些优化可能会与未正确同步的代码相互作用，从而产生看似自相矛盾的行为。以下是一些未正确同步的程序可能表现出令人惊讶的行为的示例。

Consider, for example, the example program traces shown in Table 17.4-A. This program
uses local variables r1 and r2 and shared variables A and B. Initially, A == B == 0.

Table **17.4-A**. Surprising results caused by statement reordering - original code

|Thread1|Thread2|
|--|--|
|1: r2 = A; |3: r1 = B;|
|2: B = 1;|4: A = 2;|

看起来，结果r2 == 2且r1 == 1是不可能的。直观地讲，指令1或指令3应该先执行。如果指令1先执行，它不应该能够看到指令4的写入。如果指令3先执行，它不应该能够看到指令2的写入。

如果某个执行呈现出这种行为，那么我们会知道指令4先于指令1，指令1先于指令2，指令2先于指令3，指令3先于指令4。这在表面上看起来是荒谬的。

然而，编译器允许重新排序任何一个线程中的指令，只要这不影响该线程本身的执行。如果指令1和指令2重新排序，如表17.4-B中的执行轨迹所示，那么很容易看出结果r2 == 2且r1 == 1可能会发生。

Table **17.4-B**. Surprising results caused by statement reordering - valid compiler
transformation

|Thread1|Thread2|
|--|--|
|1: B = 1; |3: r1 = B;|
|2: r2 = A;|4: A = 2;|

对于一些程序员来说，这种行为可能看起来是“有问题”的。然而，需要注意的是，这段代码未正确同步：

- there is a write in one thread,
- a read of the same variable by another thread,
- and the write and read are not ordered by synchronization

这种情况是*数据竞争*(data race)的一个例子（§17.4.5）。当代码存在数据竞争时，往往会出现反直觉的结果。

有几种机制可以产生表17.4-B中的重排序。Java虚拟机实现中的即时编译器(Just-In-Time compiler)可以重新排列代码，或者是处理器。此外，Java虚拟机实现所运行的架构的内存层次结构可能会使代码看起来被重排序。在本章中，我们将把任何可以重新排序代码的东西称为*编译器*(compiler)

另一个出现令人惊讶的结果的例子可以在表17.4-C中看到。初始条件，p == q且p.x == 0。这个程序同样未正确同步；它在不强制执行写入之间的任何顺序的情况下写入共享内存。

Table **17.4-C**. Surprising results caused by forward substitution
|Thread1|Thread2|
|--|--|
|r1 = p;  |r6 = p;|
|r2 = r1.x;|r6.x = 3;|
|r3 = q;||
|r4 = r3.x;||
|r5 = r1.x;||

一个常见的编译器优化涉及到复用r2读取的值来作为r5的值：它们都是对r1.x的读取操作，没有任何插入的写操作。这种情况如表17.4-D所示。

Table **17.4-D**. Surprising results caused by forward substitution
|Thread1|Thread2|
|--|--|
|r1 = p;  |r6 = p;|
|r2 = r1.x;|r6.x = 3;|
|r3 = q;||
|r4 = r3.x;||
|r5 = r2;||
现在考虑Thread 2中对r6.x的赋值发生在Thread 1中对r1.x的第一次读取和对r3.x的读取之间的情况。如果编译器决定重复使用r2的值来作为r5的值，那么r2和r5将都为0，r4将为3。从程序员的角度来看，存储在p.x中的值已经从0改变为3，然后再次改变回来了。

内存模型决定了程序在每个时刻可以读到什么值。每个线程的操作在独立执行时必须符合该线程的语义，但除此之外，每个读取所看到的值都由内存模型决定。当我们提到这一点时，我们说程序遵守了内部线程语义（ intra-thread semantics.）。内部线程语义是单线程程序的语义，可以完全预测线程的行为，基于线程内读操作看到的值。要确定在执行中线程t的操作是否合法，我们只需将线程t的实现评估为在单线程环境中执行的方式，如本规范的其他部分所定义的那样。

每当线程t的求值产生一个跨线程动作(inter-thread action)时，它必须匹配t程序顺序中下一个跨线程动作a。如果a是一个读操作，则t的进一步求值使用内存模型确定的a所看到的值。

本节提供了Java编程语言内存模型的规范，除了处理`final`字段的问题会在§17.5中描述。

本文所指定的内存模型并非基于Java编程语言的面向对象特性。为了简洁和简单起见，在我们的示例中，我们通常会展示代码片段，没有类或方法定义，也没有明确的解引用。大多数示例由包含访问本地变量、共享全局变量或对象的实例字段的语句的两个或多个线程组成。我们通常使用变量名称，例如r1或r2，来表示方法或线程的本地变量。这些变量不能被其他线程访问。

#### 17.4.1 Shared Variables

可以在多个线程之间共享的内存称为共享内存（shared memory）或堆内存（heap
memory）。

所有的实例（instance）字段、静态(static)字段和数组(array)元素都存储在堆内存中。在本章中，我们使用术语“变量(variable)”来指代字段和数组元素。

本地变量(Local variables)（§14.4）、方法形式参数(formal method parameters)（§8.4.1）和异常处理程序参数(exception handler
parameters)（§14.20）永远不会在线程之间共享，并且不受内存模型的影响。

如果两次访问（读或写）相同的变量中至少有一次访问是写操作，那么这两次访问被称为冲突的访问(*conflicting*)。

#### 17.4.2 Actions
线程间操作（inter-thread action）是一个线程执行操作，可以被另一个线程检测或直接影响。程序可以执行几种线程间操作：
- Read (normal, or non-volatile).。读取一个变量。
- Write (normal, or non-volatile)。写入一个变量。
- Synchronization actions，包括：
    - 易失性读取（Volatile read）。易失性读取一个变量。
    - 易失性写入（Volatile write）。易失性写入一个变量。
    - 锁定（Lock）。锁定一个监视器。
    - 解锁（Unlock）。解锁一个监视器。
    - 线程的（合成的）第一个和最后一个动作。
    - 启动线程或检测线程已终止的操作（§17.4.4）。
- 外部操作（External Actions）。外部操作是一个可以在执行之外观察到的操作，其结果基于执行之外的环境。
- 线程分歧操作（Thread divergence actions）（§17.4.9）。线程分歧操作只会由处于无限循环状态且没有执行内存、同步或外部操作的线程执行。如果一个线程执行了线程分歧操作，它将会被无限次地执行线程分歧操作。

线程分歧操作被引入来模拟一个线程如何导致所有其他线程停滞不前且无法取得进展。

本规范只关注线程间操作。我们不需要关心线程内操作（例如，将两个局部变量相加并将结果存储在第三个局部变量中）。如前所述，所有线程都需要遵守 Java 程序的正确内部语义。我们通常更简洁地将线程间操作称为**操作（actions）**。

An action a is described by a tuple < t, k, v, u >, comprising:
- t - the thread performing the action
- k - the kind of action
- v - the variable or monitor involved in the action.
    For lock actions, v is the monitor being locked; 
    for unlock actions, v is the monitor being unlocked.

    If the action is a (volatile or non-volatile) read, v is the variable being read.

    If the action is a (volatile or non-volatile) write, v is the variable being written.
- u - an arbitrary unique identifier for the action

外部动作元组（tuple）包含一个额外的组件，其中包含由执行动作的线程感知的外部动作的结果。这可以是有关动作成功或失败的信息，以及由动作读取的任何值。

外部动作的参数（例如写入哪些字节到哪个套接字）不是外部动作元组的一部分。这些参数由线程内的其他操作设置，并可以通过检查线程内部语义来确定。它们在内存模型中没有明确讨论。

在无终止的执行中，并非所有的外部动作都是可观测的。无终止的执行和可观测的动作在第17.4.9节中讨论。

#### 17.4.3 Programs and Program Order
每个线程t执行的所有线程间动作中，线程t的程序顺序是一种总序，它反映了这些动作按照线程t的内部语义执行的顺序。

一个动作集合是*顺序一致*(sequentially consistent)的，当且仅当所有的动作出现在一个总序列（执行顺序）中，并且该序列与程序顺序一致，并且每个变量v的读操作r都看到写操作w写入v的值，满足：
• w在执行顺序中排在r之前，且
• 没有其他的写操作w'满足w在执行顺序中排在w'之前且w'在r之前。
顺序一致性是关于可见性和顺序的一个非常强的保证，程序执行中的所有单个操作（如读和写）都有一个与程序顺序一致的总序列，并且每个单个操作都是原子的，立即对每个线程可见。
如果程序没有数据竞争，那么程序的所有执行看起来都是顺序一致的。
顺序一致性和/或没有数据竞争仍然允许由需要被视为原子的操作组成的错误。

如果我们使用顺序一致性作为我们的内存模型，我们讨论过的许多编译器和处理器优化都将是不合法的。例如，在表17.4-C中的跟踪中，一旦对p.x的写入3发生，后续对该位置的读取将需要看到该值。

#### 17.4.4 Synchronization Order

每个执行过程都有一个同步顺序（Synchronization Order）。同步顺序是执行过程中所有同步操作的总顺序。对于每个线程 t，线程 t 中的同步操作（§17.4.2）的同步顺序与线程 t 的程序顺序（§17.4.3）是一致的。

同步操作引入了“synchronized-with”关系，其定义如下：
- 监视器m上的解锁操作与后续对m的锁定操作建立同步关系（其中“后续”是按照同步顺序定义的）。
- 对volatile变量v的写入（§8.3.1.4）与任何线程后续读取v建立同步关系（其中“后续”是按照同步顺序定义的）。
- 启动线程的操作与启动的线程中的第一个操作建立同步关系（ synchronizes-with）。
- 将默认值（零、false或null）写入每个变量与每个线程中的第一个操作同步。

    尽管在分配包含变量的对象之前将默认值写入变量可能看起来有点奇怪，但从概念上讲，每个对象都在程序开始时创建，具有其默认初始化值。
- 线程T1中的最后一个操作与另一个线程T2中检测到T1已终止的任何操作同步。
    T2可以通过调用T1.isAlive()或T1.join()来完成这一点。
- 如果线程T1中断线程T2，则T1的中断与任何其他线程（包括T2）确定T2已被中断的任何点同步（通过抛出InterruptedException或调用Thread.interrupted或Thread.isInterrupted）。

同步-源的边缘称为释放（release），目标称为获取（acquire）。

#### 17.4.5 Happens-before Order
两个动作可以通过 happens-before 关系进行排序。如果一个动作 happens-before 另一个，则第一个动作可见并在第二个动作之前排序。如果我们有两个动作 x 和 y，则写作 hb(x，y) 表示 x happens-before y。
• 如果 x 和 y 是同一线程的动作，并且 x 在程序顺序中出现在 y 之前，则 hb(x，y)。
• 对象的构造函数的结束与该对象的 finalizer 的开始之间存在一个 happens-before 边缘。
• 如果动作 x 与后续动作 y 同步，则我们也有 hb(x，y)。
• 如果 hb(x，y) 和 hb(y，z)，则 hb(x，z)。
类 Object 的 wait 方法（§17.2.1）与锁定和解锁动作相关联；它们的 happens-before 关系由这些相关动作定义。
需要注意的是，两个动作之间存在 happens-before 关系并不一定意味着它们在实现中必须按照这个顺序进行。如果重新排序产生与合法执行一致的结果，则它不是非法的。

例如，由线程构造的对象的每个字段写入默认值不需要在该线程开始之前发生，只要没有读取观察到该事实即可。

具体而言，如果两个动作之间存在 happens-before 关系，则它们不一定按照这个顺序发生对于它们之间没有 happens-before 关系的代码来说。例如，在一个线程中的写操作与另一个线程中的读操作存在数据竞争时，它们可能会以不同的顺序发生。
happens-before 关系定义了数据竞争发生的时间。
一组同步边 S 是足够的，如果它是最小的集合，使得 S 与程序顺序的可传递闭包确定了执行中所有 happens-before 边。这个集合是唯一的。
由上述定义可知：
- 在monitor上的解锁操作 happens-before 该monitor上的每个后续锁操作。
- 对 volatile 字段（§8.3.1.4）的写操作 happens-before 该字段的每个后续读操作。
- 对线程的 start() 调用 happens-before 该线程中的任何操作。
- 一个线程中的所有操作 happens-before 任何其他线程成功从该线程的 join() 中返回。
- 任何对象的默认初始化 happens-before 程序的任何其他操作（除了默认写操作）。
当程序包含两个冲突的访问（§17.4.1），它们没有被 happens-before 关系排序时，它被称为存在**数据竞争**。
除了跨线程动作之外的其他操作（如数组长度的读取（§10.7）、检查的强制类型转换（§5.5、§15.16）和虚方法的调用（§15.12））的语义不受数据竞争的直接影响。
因此，数据竞争不能导致不正确的行为，如返回错误的数组长度。
只有当所有顺序一致的执行中没有数据竞争时，程序才被正确同步。
如果程序正确同步，则程序的所有执行看起来都是顺序一致的（§17.4.3）。


这对程序员来说是一个非常强的保证。程序员不需要考虑重排序以确定他们的代码是否包含数据竞争。因此，当确定代码已经正确同步时，程序员无需担心重排序会影响他们的代码。
程序必须正确同步以避免可以观察到代码重排时出现的反直觉行为。正确同步的使用不能确保程序的整体行为是正确的。然而，它的使用使程序员可以简单地推理出程序的可能行为。正确同步的程序行为不太依赖于可能的重排序。没有正确的同步，就会出现非常奇怪、令人困惑和反直觉的行为。

我们说一个变量v的读r允许观察v的写w，如果在执行轨迹的happens-before偏序中：
- r没有被排序在w之前(即hb(r, w)不成立)，并且 
- 没有中间的写w'写入v(即没有写w'写入v使得hb(w, w')和hb(w', r)都成立)。

非正式地说，如果没有happens-before排序来阻止读取，那么允许读取r看到写入w的结果。

一组动作A是happens-before一致的，如果对于A中的所有读r(其中W(r)是r看到的写入动作)，要么不成立hb(r, W(r))，要么存在A中的一个写w，使得w.v = r.v并且成立hb(W(r), w)和hb(w, r)都不成立。

在happens-before一致的动作集中，每个读取都可以通过happens-before排序看到允许看到的写入。

Example 17.4.5-1. Happens-before Consistency

在表格 17.4.5-A 的跟踪中，初始状态 A == B == 0。该跟踪可以观察到 r2 == 0 和 r1 == 0，仍然是 happens-before 一致的，因为有执行顺序允许每个读取操作看到适当的写入。

Table **17.4.5-A**. Behavior allowed by happens-before consistency, but not sequential consistency.

|Thread1|Thread2|
|--|--|
|1: B = 1; |3: A = 2;|
|2: r2 = A;|4: r1 = B;|

因为没有同步，每个读取操作可以看到初始值的写入或者另一个线程的写入。展示这种行为的一种执行顺序是：
```
1: B = 1;
3: A = 2;
2: r2 = A; // sees initial write of 0
4: r1 = B; // sees initial write of 0
```
Another execution order that is happens-before consistent is:
```
1: r2 = A; // sees write of A = 2
3: r1 = B; // sees write of B = 1
2: B = 1;
4: A = 2;
```

在这个执行中，读取操作看到的是后面发生的写操作。这可能看起来不符合直觉，但是它符合happens-before一致性。允许读取操作看到后面的写操作有时会产生不可接受的行为。

#### 17.4.6 Executions
这里介绍了一个执行 E 的元组 < P，A，po，so，W，V，sw，hb >，包括：

- P - 一个程序
- A - 一组操作
- po - 程序顺序，对于每个线程 t，在 A 中执行的所有 t 操作构成的一个全序。
- so - 同步顺序，对于 A 中的所有同步操作，它们构成了一个全序。
- W - 一个写操作视图函数，对于 A 中的每个读操作 r，在执行 E 中，W（r）表示 r 看到的写操作。
- V - 一个写值函数，对于 A 中的每个写操作 w，V（w）表示 w 在 E 中写入的值。
- sw - 与同步有关的操作之间的偏序关系。
- hb - 操作之间的先后关系偏序关系。

请注意，synchronizes-with和happens-before元素是由执行的其他组件和良构执行的规则唯一确定的。

如果一个执行的操作集是 happens-before 一致的，则该执行就是 happens-before 一致的（§17.4.5）。

#### 17.4.7 Well-Formed Executions
我们只考虑符合规范的执行。一个执行E = < P，A，po，so，W，V，sw，hb > 是符合规范的，如果以下条件成立：

1. 每个读操作在执行中看到了对同一个变量的写操作。
所有的读写volatile变量的操作都是volatile操作。对于执行中的每个读操作r，我们有W(r)在A中，且W(r).v = r.v。当且仅当r是一个volatile读操作时，r.v是volatile变量；当且仅当w是一个volatile写操作时，w.v是volatile变量。

2. happens-before顺序是一个偏序关系。
happens-before顺序是由synchronizes-with边和程序顺序的传递闭包给出的。它必须是一个有效的偏序关系：自反的、传递的和反对称的。

3. 执行遵守线程内一致性。
对于每个线程t，在A中执行的t的操作与t在程序顺序中独立执行时生成的操作相同，每个写操作w写入值V(w)，假设每个读操作r看到值V(W(r))。每个读操作看到的值是由内存模型确定的。给定的程序顺序必须反映按照P的线程内语义执行操作的程序顺序。

4. 执行是happens-before一致的(§17.4.6)。

5. 执行遵守同步顺序一致性。
对于A中的所有volatile读操作r，既不是so(r, W(r))，也不存在一个写操作w在A中满足w.v = r.v，so(W(r), w)和so(w, r)。


#### 17.4.8 Executions and Causality Requirements
我们使用$f|d$来表示将$f$的定义域限制为$d$所得到的函数。对于$d$中的所有$x$，有$f|d(x) = f(x)$，对于不在$d$中的所有$x$，$f|d(x)$是未定义的。

我们使用$p|d$表示将偏序$p$限制为$d$中的元素。对于$d$中的所有$x,y$，$p(x,y)$当且仅当$p|d(x,y)$。如果$x$或$y$不在$d$中，则不成立$p|d(x,y)$。

一个符合规范的执行 E = < P, A, po, so, W, V, sw, hb > 通过执行 A 中的操作来进行验证。如果 A 中的所有操作都能够被执行，那么该执行就满足 Java 编程语言内存模型的因果要求。

从空集C0开始，我们执行一系列步骤，其中我们从行动集合A中选择行动，并将它们添加到一组已提交的行动Ci中，以获得一个新的已提交的行动集合Ci+1。为了证明这是合理的，对于每个Ci，我们需要证明存在一个包含Ci的执行E，满足特定的条件。
正式地说，如果存在以下条件，则执行E满足Java编程语言内存模型的因果关系要求：
• 行动集合C0，C1，...，满足以下条件：

C0为空集
Ci是Ci+1的真子集
A = ∪ (C0，C1，...)
如果A是有限的，则序列C0，C1，...将是有限的，以一个集合Cn = A结束。
如果A是无限的，则序列C0，C1，...可能是无限的，并且这个无限序列的所有元素的并集必须等于A。
• 合法的执行E1，...，其中Ei = < P，Ai，poi，soi，Wi，Vi，swi，hbi >。
给定这些行动集合C0，...和执行E1，...，Ci中的每个行动必须是Ei中的行动之一。Ci中的所有行动必须在Ei和E中具有相同的相对发生顺序和同步顺序。正式地说：
1. Ci是Ai的子集
2. hbi|Ci = hb|Ci
3. soi|Ci = so|Ci
Ci中写入的值在Ei和E中必须相同。Ci-1中的读取只需要在Ei和E中看到相同的写入。正式地说：
4. Vi|Ci = V|Ci
5. Wi|Ci-1 = W|Ci-1
Ei中所有不在Ci-1中的读取必须看到发生在它们之前的写入。Ci-Ci-1中的每个读取r必须在Ei和E中都看到Ci-1中的写入，但可能在Ei中看到不同的写入。正式地说：
6. 对于任何在Ai-Ci-1中的读取r，我们有hbi(Wi(r),r)
7. 对于任何在Ci-Ci-1中的读取r，我们有Wi(r)在Ci-1中，W(r)在Ci-1中。

对于给定的执行Ei，如果存在一个release-acquire对在你正在提交的一个操作之前发生，则该对必须存在于所有Ej（其中j≥i）。正式地说：

8. 让sswi是也在hbi的传递缩减中而不在po中的swi边缘。我们称sswi为Ei的足够同步边缘。如果sswi（x，y）且hbi（y，z）且z在Ci中，则对于所有j≥i，swj（x，y）。
如果一个操作y被提交了，那么所有在y之前发生的外部操作也都被提交了。

9. 如果y在Ci中，x是一个外部操作且hbi（x，y），则x在Ci中。

Example **17.4.8-1**. Happens-before Consistency Is Not Sufficient

“Happens-before”一致性是必要的，但不充分的一组限制条件。仅仅强制实现“happens-before”一致性将允许不可接受的行为-那些违反我们为程序建立的要求的行为。例如，“happens-before”一致性允许值“出现在空气中”，这可以通过对表17.4.8-A中的跟踪进行详细检查来看到。

Table **17.4.8-A**. Happens-before consistency is not sufficient
|Thread1|Thread2|
|--|--|
|1: r1 = x; |3: r2 = y;|
|2: if (r1 != 0) y = 1;|4: if (r2 != 0) x = 1;|

表格17.4.8-A中显示的代码是正确同步的。这可能令人惊讶，因为它不执行任何同步操作。然而，请记住，当以顺序一致的方式执行程序时，如果没有数据竞争，则程序已正确同步。如果以顺序一致的方式执行此代码，则每个操作都将按程序顺序发生，而两个写操作都不会发生。由于没有写操作发生，因此不能发生数据竞争：程序已正确同步。

由于此程序已正确同步，因此我们可以允许的行为仅为顺序一致的行为。但是，有一种执行此程序的方式是符合happens-before一致性但不是顺序一致的：
```
r1 = x; // sees write of x = 1
y = 1;
r2 = y; // sees write of y = 1
x = 1;
```
这个结果是满足 happens-before 一致性的：没有 happens-before 关系阻止它发生。然而，这显然是不可接受的：没有顺序一致的执行会产生这种行为。因此，允许读操作看到在执行顺序中后面的写操作有时可能会导致不可接受的行为。

虽然允许读取后续的写操作有时是不可取的，但有时也是必要的。正如我们在上面看到的，在表17.4.5-A中找到的轨迹需要一些读取能够看到稍后发生的写操作。由于读取在每个线程中都是第一次出现的，因此执行顺序中的第一个操作必须是读取操作。如果该读操作不能看到稍后发生的写操作，则它不能看到除所读取的变量的初始值以外的任何值。这显然不反映所有的行为。

我们将读取能否看到未来的写操作称为因果关系，因为在像表17.4.8-A中发现的情况下会出现问题。在这种情况下，读操作导致写操作发生，而写操作导致读操作发生。没有“第一因素”来解释这些操作。因此，我们的内存模型需要一种一致的方式来确定哪些读取可以早期看到写入。

像表17.4.8-A中发现的示例表明，规范在陈述读取是否可以看到稍后执行的写入时必须小心（牢记如果读取看到稍后执行的写入，则表示实际上是早期执行了写入操作）。

内存模型接受给定的执行和程序作为输入，并确定该执行是否是程序的合法执行。它通过逐步构建反映程序执行的操作集来实现这一点。通常，下一个要提交的操作将反映可以由顺序一致执行执行的下一个操作。但是，为了反映需要看到稍后写入的读取，我们允许某些操作比其先行操作更早地被提交。显然，有些操作可能会被提前提交，有些操作则不会。例如，在表17.4.8-A中，如果其中一个写操作在变量的读操作之前被提交，则读操作可以看到该写操作，从而导致“out-of-thin-air”结果发生。非正式地说，如果我们知道某个操作可以在不假定发生某些数据竞争的情况下发生，则允许将其提前提交。在表17.4.8-A中，我们不能提前执行任何写入操作，因为除非读操作看到数据竞争的结果，否则写入操作是不能执行的。


#### 17.4.9 Observable Behavior and Nonterminating Executions
当程序总是在某个有限的时间段内终止时，它们的行为可以简单地用它们允许的执行来理解（非正式地）。当程序可能无法在有限的时间内终止时，就会出现更微妙的问题。

程序的可观察行为是由程序可能执行的外部操作的有限集定义的。例如，只打印“Hello”的程序的行为由一个行为集合描述，对于任何非负整数i，都包括打印“Hello” i次的行为。

终止不是显式地建模为一种行为，但可以轻松地将程序扩展为生成一个额外的外部动作executionTermination，当所有线程都终止时发生。

对于总是在有限时间内终止的程序，其行为可以（非正式地）简单地用其允许的执行来理解。对于可能无法在有限时间内终止的程序，会出现更微妙的问题。

程序的可观察行为由程序可能执行的外部动作的有限集合定义。例如，仅打印“Hello”永远被描述为一组行为，其中对于任何非负整数i，都包括打印“Hello”i次的行为。
终止并没有被显式地建模为一种行为，但可以轻松地扩展程序以生成一个名为executionTermination的额外外部动作，当所有线程都已终止时该动作发生。

我们还定义了一种特殊的hang动作。如果行为由包含hang动作的外部动作集描述，则表示在观察到外部动作后，程序可以运行无限长的时间而不执行任何其他外部动作或终止。如果所有线程都被阻塞或者程序可以执行无限次数的动作而不执行任何外部动作，程序就会hang。

线程可以在各种情况下被阻塞，例如当它尝试获取锁或执行依赖于外部数据的外部动作（例如读取）时。

执行可能导致线程无限期地被阻塞而导致程序未终止。在这种情况下，被阻塞线程生成的动作必须包括使该线程被阻塞的所有动作，包括引起线程被阻塞的动作，但不包括线程在该动作之后生成的任何动作。

为了推理可观察行为，我们需要讨论一组可观察动作。

如果O是执行E的可观察动作集合，则集合O必须是E的动作A的子集，并且只能包含有限数量的动作，即使A包含无限数量的动作。此外，如果动作y在O中，且hb（x，y）或so（x，y），则x在O中。

注意，可观察动作集不仅限于外部动作。相反，只有在可观察动作集中的外部动作被视为可观察的外部动作。

如果B是程序P的可允许行为，则B是一个有限的外部动作集合，且满足以下条件之一：

- 存在程序P的执行E和可观察动作集O，且B是O中的外部动作集（如果E中的任何线程以阻塞状态结束且O包含E中的所有动作，则B也可以包含hang动作）;
- 如果存在一个程序P的执行E和一个可观察行为集合O，使得B是O中的所有外部行为的集合（如果E中的任何线程以阻塞状态结束且O包含E中的所有行为，则B也可以包含一个挂起动作）; 或者存在一个动作集合O，使得B由一个挂起动作和O中的所有外部行为组成，并且对于所有k ≥ |O|，存在一个P的执行E，其动作为A，存在一个动作集合O'，满足以下要求：
    - O和O'都是A的子集，满足可观察行为集合的要求。
    - O ⊆ O' ⊆ A
    - |O'| ≥ k
    - O' - O contains no external actions

需要注意的是，行为B并没有描述观察B中的外部动作的顺序，但是生成和执行这些外部动作的其他（内部）约束可能会强加这样的限制。
