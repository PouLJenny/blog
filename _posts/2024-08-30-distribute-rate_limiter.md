---
layout: post
title:  "常用的限流算法"
date:   2024-08-30 01:22:00 +0800
categories: 分布式系统
tags: 分布式系统
permalink: /distribute/rate_limiter
published: true
publish_file: 2024-08-30-distribute-rate_limiter.md
toc: true
---
# 限流算法

## 固定窗口

固定窗口算法（Fixed Window Algorithm）是一种简单的限流算法，它将时间划分为固定长度的窗口，并在每个窗口内对请求数量进行计数。该算法适用于需要简单实现且对流量控制要求不高的场景。

操作步骤:
1. 初始化：
    - 定义固定窗口的时间长度（如1分钟、1小时等）。
    - 设置允许的最大请求数量（阈值），即在每个时间窗口内允许的最大请求数。
    - 初始化计数器和窗口开始时间。
2. 处理请求：
    - 当一个请求到达时，首先检查当前时间是否在窗口范围内。
    - 如果当前时间在窗口范围内，检查计数器是否超过最大请求数量。
    - 如果计数器未超过阈值，则允许请求通过，并增加计数器。
    - 如果计数器已超过阈值，则拒绝请求。
    - 如果当前时间已超出窗口范围，则重置计数器，并开始新的窗口。
3. 更新窗口：
    - 每次请求到来时，都需要检查是否需要切换到新的时间窗口。
    - 如果需要切换到新的窗口，重置计数器并更新窗口开始时间。

### 优缺点

优点:  
- __实现简单__：算法逻辑清晰，易于理解和实现。
- __性能开销小__：算法在每个请求到来时只需进行简单的计数和时间检查，性能开销较小。
缺点:  
- __窗口边界问题__：在窗口的边界处，可能会产生请求的突刺现象。例如，若某个窗口内的请求数接近阈值，则在窗口的结束和新窗口的开始之间可能会产生高请求量。
- __不平滑流量__：无法平滑处理流量波动，可能导致请求量在窗口边界时的不均衡处理。


## 滑动窗口
滑动窗口算法通过跟踪一个窗口内的请求数来限制流量。相比固定窗口算法，它可以平滑突发流量，因为窗口在每个请求到来时滑动更新。


操作步骤：
1. 初始化:
   - 定义滑动窗口的时间范围（例如，1分钟、5分钟）。
   - 初始化一个用于记录请求时间戳的队列（或者其他数据结构，如链表）。
2. 请求处理:
   - 当一个请求到达时，获取当前的时间戳。
   - 将当前请求的时间戳加入到队列中。
3. 清理过期请求：
   - 遍历队列，删除所有时间戳早于当前时间减去窗口时间的请求。这些请求已经不在当前的滑动窗口范围内。
4. 检查请求数量：
   - 清理过期请求后，检查队列中剩余的请求数量。
   - 如果请求数量超过了预设的阈值，则拒绝当前请求（限流）。
   - 如果请求数量未超过阈值，则允许当前请求通过。
5. 返回响应：
   - 根据请求数量的检查结果，返回相应的限流或通过响应。


### 优缺点

优点:
- __实时性强__：滑动窗口算法能够精确地计算在当前窗口内的请求数量，并动态调整限流策略。这使得它在处理突发流量时比固定窗口算法更加灵活和精准。
- __平滑流量__：由于滑动窗口会随着每个请求的到来而更新，能够有效地平滑流量，避免固定窗口算法在窗口边界可能产生的流量突增问题。
- __避免流量突刺__：相较于固定窗口算法，滑动窗口算法能够更好地避免因流量集中在窗口边界时产生的突刺情况，提供更稳定的限流效果。
- __灵活性高__：滑动窗口可以根据不同的时间间隔进行设置，比如秒级、分钟级，能够适应多种不同的限流需求。

缺点：
- __实现复杂度较高__：与其他简单的限流算法（如固定窗口、计数器算法）相比，滑动窗口算法的实现更为复杂。它需要维护一个包含时间戳的队列或类似数据结构，并进行频繁的更新和清理操作。
- __性能开销大__：由于需要在每次请求到达时更新窗口并清理过期的请求，滑动窗口算法在高并发情况下可能会带来较大的性能开销，尤其是需要高频率处理请求的场景。
- __内存占用较大__：滑动窗口算法需要存储窗口内的所有请求时间戳，因此在大规模、高频率的请求环境中可能会消耗较多的内存资源。
- __不适合长时间窗口__：对于非常长时间的窗口（例如几小时或一天），滑动窗口算法可能需要维护大量的请求记录，这将进一步增加内存占用和处理复杂度。

## 漏桶算法

漏桶算法（Leaky Bucket Algorithm）是一个经典的流量控制算法，用于平滑网络流量和限制数据传输速率。它的核心思想是将请求或数据放入一个“桶”中，以恒定的速率“漏出”处理，如果桶满了，则丢弃多余的请求或数据。

操作步骤：
1. 初始化：
    - 设置漏桶的容量（即桶的最大能容纳的请求数量）。
    - 设置漏桶的出水速率（即处理请求的速率，通常是每秒能处理多少请求）。
    - 初始化当前桶中存储的请求数为0。
2. 请求处理：
    - 每当一个请求到达时，首先尝试从桶中漏出处理请求，即根据时间间隔计算应该漏出的请求数量，并更新桶的状态。
3. 漏出更新：
    - 计算自上次更新后，漏桶应漏出的请求数量。这可以通过当前时间减去上次处理时间，乘以出水速率得到。
    - 如果桶中有请求且漏出量大于0，则减少桶中的请求数。
4. 请求是否被接受：
    - 如果当前桶中存储的请求数小于桶的容量，则将新的请求加入到桶中，并允许请求通过。
    - 如果当前桶已满，拒绝新的请求。
5. 更新状态：
    - 记录这次请求的时间戳，以便下次计算漏出的请求数量。

### 优缺点

优点：  
- __平滑流量__：漏桶算法能够将突发的大量请求平滑为恒定速率的请求流，避免系统被突然的大量请求冲击。这对于保持系统稳定性非常重要。
- __恒定的处理速率__：漏桶算法以固定速率处理请求，无论输入请求的速率如何，这样可以确保系统不会因为突发流量而超载，始终保持在可控范围内。
- __简单实现__：漏桶算法的实现比较简单，易于理解和部署。它只需要维护一个计数器和处理时间间隔，相比其他复杂的算法更容易实现。
- __流量整形__：漏桶算法不仅能限流，还能将突发流量整形成平稳的流量输出，适用于需要严格控制流量输出速率的场景，如视频流传输、网络通信等。

缺点：  
- __保守限流__：漏桶算法可能会丢弃一些可以处理的突发请求，尤其是在突发流量频繁的情况下。这使得它比较保守，可能无法充分利用系统的处理能力。
- __不适合处理突发流量__：漏桶算法对于突发流量的处理较为严格，如果短时间内有大量请求涌入而桶已经满了，那么这些请求会被丢弃。这可能导致用户体验下降。
- __静态出水速率__：漏桶算法的出水速率是固定的，这在面对动态变化的流量时可能不够灵活。例如，当系统负载较低时，可能希望处理更多的请求，但漏桶算法无法动态调整出水速率。
- __丢失请求__：如果输入请求速率持续高于出水速率，桶很快就会满，多余的请求会被直接丢弃。这在某些场景下可能导致较高的请求丢失率。


## 令牌桶算法

令牌桶算法中，系统以固定速率生成令牌，令牌可以积累到一定上限。当请求到来时，如果有令牌则处理请求，并消耗一个令牌；如果没有令牌，请求被拒绝。这种算法允许一定程度的突发流量，是较为灵活的限流算法。

1. 初始化：
    - 设置令牌桶的容量（即桶的最大令牌数量）。
    - 设置令牌的生成速率（即每秒生成多少令牌）。
    - 初始化当前桶中令牌的数量为0。
    - 初始化上次生成令牌的时间戳。
2. 令牌生成：
    - 定期或在每次请求到来时，计算自上次生成令牌以来应生成的令牌数量。
    - 更新当前令牌数量，确保不超过桶的最大容量。
3. 请求处理：
    - 当请求到来时，检查当前桶中的令牌数量。
    - 如果桶中有足够的令牌，则从桶中取出一个令牌，并允许请求通过。
    - 如果桶中没有足够的令牌，则拒绝当前请求（或在某些实现中，可能会排队等待）。
4. 更新状态：
    - 更新上次生成令牌的时间戳，以便下一次令牌生成时使用。

### 优缺点

优点
- __灵活性高__：令牌桶算法允许一定程度的突发流量，同时保持稳定的处理速率。
- __适应性强__：可以动态调整令牌生成速率和桶容量，以适应不同的流量需求。
- __简单易实现__：算法实现相对简单，易于理解和部署。

缺点
- __令牌丢失__：在高流量情况下，可能会出现令牌被丢失的情况，导致短时间内无法处理新请求。
- __突发流量控制__：虽然令牌桶算法能够处理一定的突发流量，但在非常高频的流量中，令牌的生成和使用可能会变得不够有效。

## 开源框架

- [hystrix](https://github.com/Netflix/Hystrix) 
- [resilience4j](https://github.com/resilience4j/resilience4j)
- [sentinel](https://github.com/alibaba/Sentinel)


## 相关文章

- [令牌桶算法](https://web.archive.org/web/20200923012957/https://www.jianshu.com/p/a3d068f2586d)
- [限流算法-石衫的架构笔记](https://mp.weixin.qq.com/s/icXd55HR2GiVr95d44V34w)

## EOF